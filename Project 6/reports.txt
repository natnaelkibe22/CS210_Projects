1. Hours to complete the project: ... hours
44.5
2. Provide a short description of how you approached each problem, issues you 
   encountered, and how you resolved those issues.

   Problem 1 (WordNet Data Type): ...
        The first step I did to approach this problem was reading the project and the checklist real carefully. Then, I started writing every component of the problem, deducting the problem to every little pieces. The next step was trying to understand how the wordnet program works such as its files, instance variables or test client. So I know what codes are expected of me to make the program work. First time, I really had hard time understanding the purpose of the instance variables. But as time went by, I came to understanding of every component of the program. Things were not clear on the project checklist or they were not helpful at all. For this project, the checklist gives 10% hint to my perspective. For example, it was not really clear how to setup instance variables of constructor. But I did a little digging and thinking and approached it with the best way I could. For instance, it was really confusing to me if I am going to use two for loops or separate loops for setting the Digraph and two symbol tables. The third confusion was understanding the synsets file. I did not write the constructor since I did not understand synset and hypernyms file. Later, I understood the synset file which led me to solve a portion of the constructor. 
        I did not know about the nouns on the synset file. I thought I just needed to separate the each line by comma and put into into an array. But I did not know again I needed to separate the index 1 of the array or synset nouns by space. After this understanding, atleast everything about the problem was easier. On the project write up, I did not understand why the performance requirements of the constructor was atmost linearithigmic since I thought there was no way to set the symbol table without using two loops for the seprating by comma and space which makes it unefficient, quadratic. The main problem when I was solving each problem was thinking that I strictly needed to solve the problem using the constraints given on the project write up which limited my thought process to solve the wordnet. I already learned to understand that the hypernyms file was responsible for mapping the vertices on graph. The checklist was very clear on how to set up the digraph for the hypernyms. 
        The next step was setting up ShortestAncestralPath which needed to be solved before the wordnet in order for the wordnet to compile. Despite problem 1, wordnet, needed to be understood and read first but the ShortestAncestralPath needed to be solved before the wordnet inorder for the wordnet program to function correctly which was not clearly stated on the project write up or checklist. So I learned to understand this when I reached the last two methods of wordnet. Since both methods needed to written after ShortestAncestralPath program. I commented them out and tested wordnet to check if the constructor and methods are functioning well. Then, I started writing a code for program 2 in order to approach the rest of wordnet program. 
        Generally, problem was solved successfully despite does not meet the project minimum time requirements. It was a fun and challenging problem. But it was not clear if problem 2 two needed to be solved in order to solve the last two methods of problem 1. 
         
   Problem 2 (ShortestCommonAncestor Data Type): ...
        This problem I would say is one of the trickiest since I jumped into solving it in the midst of solving problem 1. It was harder for me to concentrate and understand everything this problem needed. I only had a very basic understanding of this problem. I did not understand the checklist or project write up for this program. I only knew what the project needed me to write in order to solve the last two methods in problem 1. My later confusion about this problem came to me after looking at the sources and not finding BreadthSearch so I had to import it which I thought it would create a unsafe warning. At first, I thought do the instructor wants us to solve without using the BFS API and I thought there is no way to do that so I imported it used it. Since the problem included distances and nearest neighbor, It was appropriate to use the BFS. It was mentioned at the end of the checklist to use the BFS. 
        Secondaly, I had a hard time understanding length and ancestral path method despite my good understanding of the concept. I literally had no idea how to solve it but then I had an idea to solve it using two for-each loops, exchanging the source vector to be v and w. Going into BFS adjacent to v and w and comparing the distances which did not work at the end. So I went to the api for the BFS and used it. I used the algorithm used on the BFS api and tweaked it a bit so it works with my shortest ancestral distance and path. So I needed to implement this whole algorithm for all the methods on ShortestAncestralPath program which makes the codes too verbose and inefficient so I added a my own helper method. I implemented the BFS search algorithm to find the minimum ancestral distance and ancestor. So the delimeter I use for the method to print the distance or the actual vertex is a boolean operator. If I sent true to the helper method, it means it returns the distance whereas false for the ancestral vertex. But it uses the same algorithm to solve the distance and the vertex. I used a queue in order enqueue and dequeue vertexes like the bfs method. I also used marked and disTo arrays in order to save the marked arrays so I do not have to traverse them again once marked. So the important comparison was adding bfs.distTo(curr) + distTo(curr) < min to find the total minimum path that leads to the nearest ancestral hypernym. So I implemented the same method for Iterable Integer also. 
       I did not find any use using separatedchaininghashing. I had no idea how to use it or what to do with it. Probably, it would have made my program more efficient than my basic and simple solution.       
   Problem 3 (Outcast Data Type): ...
       This problem was one of the quickest and easiest one if both problem 1 and problem 2 are solved correctly. So the first thing I did to solve this problem was looking at the question and test client to see what type of code I need to get the result. I also needed to understand the concept of outcast noun which was vague at the start. After understanding, outcast noun is the noun that is related farthest. The formula was also given which was very helpful. So I knew right away what I need to do in order to solve this problem. I knew write away I needed to use two loops, one for the first noun and the second one for the second noun. Then I used the given distance formula from the problem to sum up all the distances between each noun. Then compare it to the maximum distance and if it is greater then set the maximum distance the new distance. Pretty much this problem was clear and easy. 
3. Did you receive help from anyone? List their names, status (classmate, 
   CS210 grad, TA, other), and the nature of help received.

   Name               Status       Help Received
   ----               ------       -------------
B. Nissenbaum        student      problem 1 and problem 2 on piazza
pr. Swami Iyer       professor     problem 1 and problem 2 on piazza
   ...                ...          ...

4. List any other comments here. Feel free to provide any feedback on how
   much you learned from doing the assignment, and whether you enjoyed
   doing it.
     Overall, this problem was a success despite my unefficient way of solving it. Atleast, I finished the project. The main drowback from this project was many things on this problem were unclear and unexplained. For instance, I did not know I had to solve problem 2 before problem 1 despite we need to problem 1 and solve some part of it first. Then, the checklist for problem 2 was not thorough and was not as helpful as the actual project writeup. But the checklist for problem 1 was better than problem 2. Many of the methods were not explained like they were in the past projects. If everything was explained, I am pretty sure. I wouldn't have hard time solving them. The questions were not as hard as the last projects which needed extreme amount of time. I enjoyed it. Keep up the good work. 